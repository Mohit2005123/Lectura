Hello ji how are you all 
This is lakshya and we are on lecture number 13 of OS
And we are going to continue some algorithms of cp schedule 
In last lecture we have learnt about FCFS scheduling algorithm 
Which is the most simple scheduling algorithm 
Now we going to learn about some more scheduling algorithms like 
SJF, shortest job first of this we will learn about its preemptive and non preemptive both versions of it
Then comes our priority scheduling and will learn about its preemptive and non preemptive both versions of it
Then comes our special algorithm which is round robbing, ok 
This video is sponsored by coding ninjas,
India&amp;#39;s leading coding education platform 
Many product based companies like amazon, adobe, commvault
Focus mainly on OS part in their technical interviews
So for clearing this interviews your OS part should be very strong 
So coding ninjas provides you comprehensive and in-depth course
Which covers all these concepts very well 
Along with that, all the theoretical concepts are teached by mapping LINUX operating system 
Along with course they provide you one on one doubt session  
And the faculties are from nvidia microsoft like big companies 
Other than that, you will get content for more than 12 hours
You will solve 150 + problems and hands on in 12+ projects in this course 
other than that in coding ninjas you will get many different types of courses related to computer science 
If you are interested in paid courses, I will paste link in the description
By which you will get maximum available discount, thank you
So at first we will start with SJF which is shortest job first 
Shortest job means, the job which have the shortest brust time,
That is the jobs which is inside the queue, in that I will check which job has shortest brust time
Shortest brust time means which will execute most quickly, that is my thinking 
So I will give that to CPU first, ok  
Then later I will give them which have more brust time 
Why I am doing so, first let write it 
Process with least brust time will get CPU 
But why I am doing this like that 
We have seen in the previous lecture, that in FCFS  when we were scheduling the process with higher burst time 
Then average scheduling time get increased, I call it as convoy effect
So by resolving it slightly there is a SJF algorithm is there
Now we are discussing the non preemptive version of it 
That means if the process gets the CPU, there is no chance of preemption again 
In this the main problem is that we say the process which have the least burst time 
We will give it the CPU, but this is hard task
Say which process comes 
Lets take a example P1  P2  P3 are there 
Now I have to find the BT of them 
Now I have not scheduled it yet, before that OS is applying heuristics
Heuristics means it is trying to guess, it will try check if any logic behind this or not 
It will guess the burst time of P1, it will check its size, code size or the old history if P1 has come, then how much time it has taken 
According to that I am trying to find the burst time , that means I am estimating 
So this is fully based on estimation, ideally finding the burst time is nearly impossible task
 So I am going in this hope, that the burst time my algorithm have found will be right 
On this behalf I will schedule that 
This can be possible, like you have found this burst time as 2 second for that 5 second and of this 10 second 
So for P1 the burst time is minimum so I will give CPU to it 
But this could be possible that that the BT for that is not 2 second its 20 second, right 
I don&amp;#39;t know as I haven&amp;#39;t seen the code yet I can&amp;#39;t find the execution
So this is the big problem with this, this is a drawback of it to find its execution 
Now how its work, lets go to that 
So lets take a example, small example 
This are processes 
So this is my problem statement 
Now I will try to make its gantt chart according to shortest job first non preemptive version
Gantt chart will be like this, I will start at t=0 
You should take care of that it is non preemptive 
before that I will discuss, the BT here are found by estimation I don&amp;#39;t know their actual BTs 
So first will come whose arrival time is 0 
So P1 is in queue, I have scheduled P1  
As it is non preemptive it will not preemptive opposite
So it will run up to its burst time, so its run for 8 second 
Now when 8 seconds got over in clock 
so I will have these three processes, right 
As its arrival time is 3, latest process arrival time is 3 
So in ready queue this three process have came 
Now I will take P2, so its burst time is 4, 8+4 = 12 seconds 
So P2 got over at 12 seconds 
Now if I see I have two jobs remaining 
Now I will match whose burst time is minimum 
So its burst time is minimum 
Now instead of P3  P4 will schedule here 
In case of FCFS P3 will get schedule, but in this case we will schedule P4 
Now P4 will run for 5 seconds, so total will be 17 seconds
Now remaining is P3 we will schedule that and it will run for 26 seconds 
Now I write its CT quickly 
Ct will be 8 12 26 26 17 
If I find its turn around time, so TAT will be CT -AT 
Turn around time, BT, CT this terminology we will use in coming lectures 
So make these terms clear by watching my lecture 12 
Lets find the turn around time for this it will be 8 second this 11 second 
For this 24 second and for this it will be 14 second 
This is not burst time I say this as wait time, WT = TAT - BT 
For this it will be 0 seconds this will come 7 this 15 and for this it will be 9 seconds 
f I find its average then its average will be wait time will be 7.75 seconds 
So we have done a example of non preemptive version and observed its average waiting time 
So as we solved a example what is our criteria to pick the process 
that is arrival time and BT 
On behalf of BT, we are looking on the arrival time the processes which will arrive that will be in queue 
Another one whose burst time is minimum that will be my criteria
So this criteria is used in SJF 
Now I go to its preemptive version, preemptive SJF 
Now saw in non preemptive that, if a process get a CPU then I don&amp;#39;t preempt it 
Now see what problem may arrive if I don&amp;#39;t preempt it 
Assume that P1 process which comes at arrival time 0, its burst time is 80 instead of 8 
Then if you see, only first job run for 80 seconds remaining jobs will wait for 80 seconds as preemption is not happening 
So this will be a victim of convoy effect 
Rest jobs will be starving as they will not get the CPU ones 
Lets solve it slightly, try it optimize it using preemptive version 
Lets solve this example only for this version 
Let me draw the question first, so quickly I have drawn the function 
So this is our ready queue, liker this after some time it will increase according to arrival time 
Now what will be its criteria here, criteria will be AT +BT but another one will be added 
That is here will be preemption, and that will be like 
At that particular point 
Assume at starting arrival time is 0 so P1 process will come 
So when there is only a process in ready queue, in this case only P1 will get scheduled as remaining processes haven&amp;#39;t came 
But as P1 starts running, P1 get s the CPU and it starts to execute 
And it executed for 1 second, then another process will come in ready queue that is P2
Now what is the burst time for P2, that is 4 
That is lesser than burst time of P1 
In this case I will preempt P1 
First P1 will schedule run for 1 second then P2 will come 4 second is its burst time 
So P1 will now preempt 
Now create its gantt chart and try to understand from that 
In staring when time be t=0 we will schedule P1, it will run for 1 sec 
When it run for 1 second P2 will come whose burst is less, because of less burst time I preempted P1 
After the preemption of P1, I scheduled P2, P2 will come here 
Now P2 will rum for how much, P2 will run for 4 second as at the end of 4 second 
I will have the processes up to that time 
that means P3 and P4 will also came, but the burst time of P3 and P4 that is lesser than P2 
So P1 will run, full up to termination state it will be scheduled 
5 second will come here as it run for 4 second 
Now it have executed, P2 is done 
And ne thing we have forgotten that when P1 ran for 1 second 
So its remaining burst time will be 7 
Now I will see, that which process is of minimum burst time
S here P4 is of the minimum burst time that is 5 seconds 
So I have taken P4 and scheduled it for 5 seconds and total will be 10 seconds 
Now after this whose burst time is minimum, is P1 
Now P1 will get completely scheduled as P1 have less burst time than P3 
And no other process is coming in this ready queue 
So I will schedule it completely that is 17 seconds 
Now remaining is P3 P3 will run for 9 seconds that will be 26 
So we have drawn its gantt chart, now I will write its CT quickly 
CT will 17 seconds for this, 5 seconds for this, 26 seconds for this and 10 seconds for this
And TAT will be 17 seconds for this, 4 seconds for this, 24 seconds for this and 7 seconds for this
Now if I find WT that is TAT- BT will be 9seconds for this, 0 seconds for this
15 seconds for this and 2 seconds for this
Now if I find the average wait time then it will come 6.5 minutes 
Now I have done some optimization, and after that its WT got decreased 
Now lets ask a question, that is there will be convoy effect in that 
So convoy effect will not be there in this , reason is 
Assume that a first job comes and its burst time is very high lets say 80 seconds as the first case 
Then also this will start to run, but whenever process comes having lower burst time 
We preempt the first job and provided CPU to the next job 
In this case there is no convoy effect, because whenever any process with lower burst time 
Will come we will schedule that, then if another will come with lower burst time come then also we will schedule it 
So this way we are avoiding convoy effect 
Why convoy effect is not coming in this, first you have to understand why it comes 
If in first, a job comes whose burst time is very high then it will hack the CPU for very long time 
And remaining job will starve for that time, so that is convoy effect
But in these our criteria is that whose BT is less I will give that one 
So whenever a job comes whose BT is lower, then it will schedule first 
So, the longer jobs whose BT is high, they will shift lower and lower 
Because of that average waiting time will be the lowest 
But in this the big challenge in SJF is, it is nearly impossible to implement it
The reason is that, I can&amp;#39;t know the BT before hand 
If I see practically that how I can know it before hand that this process will take how much burst time 
Ideally the programmer have thought that my program will run nicely 
But lets say there is a while one loop in it, which will make the program erroneous and it is running and running 
So the programmer had assumed the burst time to be 70 seconds but it will be unlimited 
So this is the main issue in SJF, so we discussed SJF 
And we learned that preemptive version is better than non preemptive version 
As preemptive doesn&amp;#39;t have convoy effect, but in non preemptive version it is there
So it is a algorithm with less starvation 
Next we will start discussing the algorithm, which is priority scheduling 
Up to here we are discussing about the base time of the jobs no priority is there other than this 
So I can say SJF is a special case of priority scheduling as 
There is no assigned priority other than burst time
So I can say which have lowest burst time at that time that will be its highest priority 
But in this algorithm, what we do is we basically we assign priority to each job 
This is our ready queue, when job comes in ready queue P1 P2
So I will set priority, lets say its priority is 2 its priority is 4 
Now I say which have the highest priority that will be scheduled first
Firstly I discuss its non preemptive version of that 
You got up to here that non preemptive is useless, so this is also useless
Lets see it with a example, I quickly draw a example 
This is, I can say a question so how we schedule it 
So lets make a gantt chart this is vert important 
So what is the criteria here, here our criteria is priority 
Whose priority is higher at that point of time, that will be scheduled 
As it is non preemptive version so once any job gets the CPU then we don&amp;#39;t preempt any job 
So lets start, so at t=0 we have P1 so P1 get scheduled 
once it get the CPU then it will execute for 4 seconds, as it executed for 4 seconds 
So what jobs we have whose arrival time is up to 4 seconds ?
1 get executed now 2 3 4 5, in them more priority will be of P4 
So next P4 will schedule, so it will execute for 5 seconds so total will be 9 
So as 9 seconds got completed so all the processes will come into ready queue as last arrival time was 6 
Now I will pick up the process which have the highest priority 
So highest priority among them will be of P6 as so total will be 13 seconds 
After P6 P7 priority is the highest that was 9 so that will run for 6 seconds 
That is up to 19, then comes the 5th process,P5
that will run for 1 seconds, then P3 will come 
P3 will run for 3 seconds so it will run up to 23 
Now P2 is remaining for 2 seconds it will run up to 25 
So that is our gantt chart 
Now we will write its values 
CT will be 4 for this, 25, 23, 9, 20, 13, 19 
One thing here is to notice very time we lower the lowest priority jobs 
And schedule the highest priority jobs, by this a problem arise keep that in mind we will be discussing it after some time 
And TA and WT I ant to calculate it by yourself I quickly draw it I  have solved it previously 
Average waiting time is 9.714 seconds 
Now lets go to its preemptive version 
Preemptive priority scheduling 
Lets discuss its preemptive version, priority is assigned in this also 
But at that point of time as the arrival time increases process will come over and over 
Whenever a process of higher priority comes current process which  is scheduled 
That we will preempt 
So my criteria here will be I will go according to the higher priority 
Lets draw a example of that  and drawing the gantt chart of that quickly 
Lets draw its gantt chart if this 
At first at t=0, we have P1 process, that will be scheduled first 
Whenever P1 process gets scheduled and it runs for 1 second 
So ten P2 also comes, If P2 comes to ready queue then I will check  
Whose priority is higher scheduled is P1 but priority is higher for P2 
So after 1 second it will run for 1 second and P2 get scheduled
So as it run for 1 second so we write its burst time as 3 instead of 4 
Now P2 will run for 1 second, now why it  is running for 1 second why it is not running for half second 
We assume as our algorithm checks after each second that any  process came in ready queue 
It is assumption and is based on implementation how you implement the schedule algorithm 
So P2 will run for 1 second then another process will come P3 
IS P3 priority is higher, yes it is higher then P3 will schedule 
And run for 1 second, now burst time for P2 is now 1 second 
Now P3 will run for 1 second P4 will come now priority of P4 will be higher 
Now P4 will execute, now next higher priority job is coming after 2 seconds 
So it will run for 2 seconds, as it run for 2 seconds now arrival time becomes 5 
Now here whose priority is highest, so here priority will be highest in this part is for P6
As it ran for 2 seconds and P6 will schedule as P6 is the highest priority then whole P6  will get scheduled 
P6 will run for 4 seconds so 5+4 is 9 
Now P6 is out, now I have the highest priority is P4 
So I will schedule P4 again it will run up to termination so it will run up to 11 seconds
We did a mistake here, P4 has ran 2 seconds so it will run up to 12 seconds of CPU time
Now P4 is also done now we have P7 as it have the highest priority so we whole P7 
P7 will run upto 6 seconds that it will run upto 18 seconds 
Now I have P5 as the highest priority that is 8 
And it will run for 1 second only then it will be 19 seconds 
Now P5 is also out of the game, now I have P3 remaining 
After P5 I will run P3, and it will run for 2 seconds that will run up to 21 seconds 
After that which process will come as P3 is out that is P2 it will run for 1 second that will be 22 
Then I remain with P1, P1 will run 3 seconds up to 25 seconds 
Look how much hardwork we did for solving this It having that much overhead 
You are requiring this much hadrwork to solve this, so the algorithm of CPU which switching the context repeatedly 
It have to do many context switching for doing 1 job 
So in this case there is many overheads 
And you can see the lowest criteria process gets down and down and highest will get the chance 
So there is no respect for lowest priority in this game 
If I write the CT will see from right to left So CT of P1 is the highest 25
For this it is 22, for this it is 21,for this it is 12, for this it is 19, for this it is 9, for this it is 18
P7 has ran at 18 second, you can see hare even though for P2 job burst time is 2 second 
So ideally if it was SJF then we would have executed it before
But in this case it s taking 22 seconds, now for this reason convoy effect will come to this 
How, lets say any higher priority job is coming again and again 
Means that job whose first time is high and it is coming repeatedly and priority is also high 
So the lowest priority jobs will get shifted to lower and lower 
Even though burst time of lowest priority jobs are 1 second or 2 second or low but it will wait in this case 
So in this case average wait time will increase, this is your homework you will solve this 
You find the average wait time and check that is right or not, my average wait time is 11.4 second 
You can see how high is this average wait time it is 
It is higher than its non preemptive version 
Now if I check there is convoy effect is there or not, convoy effect is there with high intensity 
As higher priority begin to come, the lowest priority job get shifted lower and lower they are not getting the chance
So this is the most problematic thing in this, convoy effect 
Now there is a extreme of convoy effect, which I call indefinite blocking 
So it biggest drawback, in both preemptive and non preemptive versions you should keep it in mind
 Is indefinite waiting, I can call it as extreme starvation 
Now what that means, lets assume this is your ready queue 
This is your P1 and P2  job and this will start to schedule
Now P3 P4 P5 job comes and this is of highest priority 
Lets assume it as 100 its 101 and its 102 
Now this will schedule on there self, lets assume this got execute and terminated 
Now you have taken P6 job and is of highest priority lets say 200 
I am taking the numbers randomly but you take that priority is increasing 
Now this lowest priority jobs take them as 1 and this as 2, so this got blocked for endless time 
As your system is running continuously,
Now assume your system is on for a long time and your highest priority jobs are coming again and again 
The lowest priority jobs will go in indefinite wait 
They will never get CPU 
I am calling this as indefinite waiting 
So I am giving a extreme example of indefinite waiting 
One rumor is there I don&amp;#39;t know it is right or wrong, even it is written in the books also
The rumor is that IBM 7094 basically this is the system MIT
This system was on in 1967 and submitted some jobs 
So many would got submitted in that like P1  P2 and so on
The lowest priority jobs got stucked in ready queue due to this  draw back scheduled algorithm
They never got the CPU, they checked it at 1973 
The lowest priority jobs got stucked in ready queue for this many years, ok
So this are extreme examples of indefinite waiting 
So for solving this problem we use a way 
See this algorithm is good as when we are learning types of operating system in that 
There is a criteria we will execute first the highest priority like our previous example 
So this problem is very big but there is a solution is also there
Solution to indefinite waiting, solution is ageing 
WE add another criteria ageing 
We gradually increase the priorities of lower priority jobs 
Its example like, in the IBM problem we saw the lowest priority jobs are stuck there 
If I used ageing method, then in every 15 seconds (this time is customizable) I will do priority +1 for there priorities
So the priority of lowest priority jobs will increase gradually increase 
So after some they will definitely get chance as ageing will increase its priority
So ageing is a way, which I use to save indefinite victims and overcome this drawback 
So we have learnt that what is priority scheduled algorithm, is a good algorithm 
But in this the biggest drawback is indefinite waiting 
We are solving it through ageing, so we have learnt about indefinite waiting 
If I ask you a question , is there is convoy effect, yes it is there
Indefinite waiting is a extreme version of convoy effect 
The highest priority jobs only getting the time even though it burst time is less, it is not getting the chance 
So average waiting time of ready queue will increase gradually 
So it is having extreme convoy effect 
Now we move on to our next algorithm, which is Round Robin(RR)
Why it is called Round Robin, as it give chance to each process which are present in ready queue 
Means every process at least will get CPU quickly 
So wait time is very less in this 
So I can say in this algorithm starvation is lowest 
As another process will get chance after some time 
As starvation is less so convoy effect is also not there 
And this is the most popular algorithm 
Today this is used in different levels of operating system 
Apart from that this is preemptive version of FCFS 
There is no criteria like priority 
Its criteria is AT +TQ( time quantum)
And its does not depend on BT 
So the problematic area of SJF was that you have to find the burst time 
Then only it will get scheduled, finding burst time is ideally not possible 
So this is not the case here, in here we use AT and time constant 
Now here time constant is coming, so this design is done for time sharing 
So we have learnt that time sharing, in which we preempt any process after some particular time quantum
Taking back it to ready queue, so in this we use this 
As AT and TQ are basic criteria so this is easy to implement 
It is easy to implement, we will discuss it when we draw the diagram
And it is created for time sharing system, time sharing used in multitasking OS
So it popularly used in multitasking OS
Lets go directly to its diagram, diagram is in the notes 
Lets directly go to the notes 
See carefully, we have a ready queue, in this ready queue 
In this ready queue there are many process are there, arrival time will increase and the process will come 
I will pick a process by FCFS method, whose At is 0 I will take that 
And I will check, that the burst time of that process is less than time quantum
Time quantum will be decided by the developer or designer of OS
If time quantum is more than burst time, process can be executed within that time constant
So in that case we will execute it and process will get terminated  
And if time constant is more than burst time, then in that case 
I will execute it execute it up to time constant 
And when time constant get expired I will preempt that process 
This can be possible that, our time constant is set 2 seconds 
And in that process remaining burst time is 2 seconds, then it will for 2 seconds and will go to terminate state
So see this is a simple diagram, I have to execute for time quantum
Burst time not required here, if burst time get increased we did wrong estimation
First of all there is no estimation happening here, process are executing according to time time quantum
If burst time is less, there is no estimation in burst time 
In real life practically it is executing for 2 seconds, then it will check if it is terminated 
If not terminated then I will put it in ready queue and if get terminated then I will put it in terminated state
This way the things are going here 
So it is easy to implement 
Lets try to solve a question of it also 
When we solve the question you notice on thing, that in this how many overheads are there
Is there is any overhead, if yes then how many are there
Lets solve a question of it 
Quickly I am drawing it, So this is my question now I will try to solve this
Simply I will be making its gantt chart 
Now look, my criteria here is arrival time and time constant 
Here 0 arrival time is for P1, so P1 process will execute first its burst time is 4 seconds 
But we are assuming tine quantum TQ as 2 seconds 
So P1 will run for 2 seconds, now at that point where P1 has ran for 2 seconds 
I am creating a queue here also, P1 has came to queue first, when 2 seconds got over 
Now which jobs have came to queue, P2 and P3 have came to queue 
So P1 has ran for 2 seconds and not went to terminate state 
So I will preempt P1 again to queue 
For the time over up to now, which jobs are in queue
Now I will schedule P2, it will run for 2 seconds 
Before that in P1 2 seconds are remaining, as P1 has ran for 2 seconds
Now P2 will run for 2 seconds, i write 4 seconds in gantt chart 
Now when 4 seconds got completed, all the processes have came to queue
Means I have P4 and P5 in the queue P3 is already there in there queue
When it ran for 2 seconds, we have change its burst time to 3 seconds
Now P2 will preempt, let write P2 here 
After that I have P3 process in the queue and I will schedule P3 
P3 will run for 2 seconds, and then it will go to terminate state 
So in 6 seconds, P3 will fully terminate 
Now in this process P6 have came to ready queue
Now P1 will process and I will pick P1 from here P1 will run for 2 seconds
It have 2 seconds remaining then this will exit this also get terminated 8 seconds over
Now when P1 terminated, no process has came as last arrival time is 6 seconds
Now next process will come is P4, I will schedule P4 
P4 will try to run for 2 seconds, but before that its burst time will be 0
S in this case also this will exit 9 seconds
now I will take P5 process, P5 will run for 2 seconds
As it run for 2 seconds then here 4 seconds will remain
This will be 11 seconds then again P5 will preempt ok 
Now P2 will get chance, it will run for 2 seconds and here 1 second will remain 
This will be 13, then P2 will preempt again after P5 P2 will again come
Now I will have P6 here, I schedule P6 this is very boring 
P6 will run for 2 seconds, here 1 second will remain 13 14 15 
P6 will again preempt, after P2 P6 stand in the queue 
After that P5 will schedule, I take P5 and it will run for 2 seconds 
15 16 17 P5 will go again in the queue
Now P2 will schedule, it will run for 18 seconds 
As 1 seconds was remaining there  
Now P2 got terminated, then P6 process will come 
P6 will run for 1 second and up to 19  seconds
And I have P5 remaining, i will run P5 whole so total it run up to 21  seconds
You can see here that it is very hard to make the gantt chart 
Because after each TQ(time quantum)I am check that I will preempt or not 
In this case overheads will increase 
Means the context switching is much more in round -robin algorithm 
Although we have removed starvation completely and convoy effect 
But for this reason overheads got increased 
We want balance of both of them 
We want minimum convoy effect as well as minimum overheads 
We tried to 0 the convoy effect but the consequence is overheads got increased 
In this case another major problem is there, we assume TQ as 2 seconds here 
If I change it to 1  second, then context switching will be more 
So there could be a question that which determines overheads in a RR algorithm ?
That determines the time quantum, if time quantum is more then overheads will be less
And time quantum is less then overheads will be more 
So this way the round robin algorithm works 
So this is the last algorithm of simple algorithm 
In the next lecture we will discuss multi level queue scheduling, multi level feedback queue scheduling
This are bit more complex, up to this implementation is simple 
in the next lecture we will discuss implementation which are mostly used in real world OS
Before ending this lecture, as always let take a look on  the notes 
I have tried to put most informative and precise information related to this algorithms in the notes
In shortest job first, we have talked about preemptive and non preemptive 
its criteria is AT+BT, its impossible task is to find its BT 
After that in preemptive version there is no convoy effect 
We talked about priority scheduling, priority scheduling preemptive and non preemptive 
In this we saw heights of convoy effect indefinite waiting extreme starvation 
For that our solution is ageing 
Round robin algorithm we have discussed preemptive of FCFS
 Time quantum is used in that in time sharing system 
This is a diagram of it 
Other than that I will personally suggest you that you implement this algorithm
you are following DSA course of love bhaiya, he is teaching you different data structures 
So by using that data structures you try to solve this scheduling algorithm 
You can do it like we are doing gantt charts here like that you take it as problem statement and try to code this and implement them
As example you can implement SJF by min heap 
You insert all the process in inside min heap and it will place the process which have lowest BT at the top 
Assume P3 have lowest BT so it will be placed above by min heap 
So min heap can be used in min heap 
Similarly you see for round robin, priority scheduling can use queue 
So implement them this is your homework, you will enjoy it 
In my time I have implemented them and I felt very nice
So lets meet in the next lecture, ok BYE !!